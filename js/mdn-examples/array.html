<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
		<title>Arrays</title>

	</head>

	<body>

		<h1>Arrays</h1>
		

	</body>

	<script>
		




		/*
			Es una lista de objetos almacenados en una variable.

			Podemos acceder a sus elementos individualmente, recorrer los elementos para hacer una misma operacion/aplicar código a todos los elementos. 

				conjunto de elementos -> proposito -> matriz -> operación 

			Sin arrays tendríamos que operar a todos por separado. 

			Podemos almacenar varios tipos de datos: cadenas, números, objetos e incluso otras matrices
	
			mezclar tipos de datos en una sola matriz. 
			
			```
			const shopping = ["bread", "milk", "cheese", "hummus", "noodles"];

			const sequence = [1, 1, 2, 3, 5, 8, 13];
			
			const random = ["tree", 795, [0, 1, 2]];

			```

			1. Longitud: 

				shopping.length // 5 elementos


			2. Acceso: 

				shopping.[0] // bread


			3. Modificación: 

				shopping[0] = "tahini";


			4. matriz multidimensional: 

				matriz dentro de otra. 

				1. Acceso: 
					
					dos conjuntos de corchetes 
				
				const random = ["tree", 795, [0, 1, 2]];
				random[2][2]; //2

				Se situa en el tercer elemento (subarray) -indice 2- y entra en el tercer subelemento (comienza desde 0). 
				
				random[3]['0']
				TypeError: random[3] is undefined


			5. indexOf(elemento):

				devolverá el índice
				

			6. push(elemento);
				
				se agrega al final


			7. push en variable: 

				con let o const quedan con los elementos hasta ese punto

				Si después actualizamos el array, no cambian estas variables. 

				const newLength = cities.push("Bristol");

				[ "Manchester", "Liverpool", "Cardiff", "London", "Newcastle", "Bristol" ]

				cities.push("Fulham"); //7

				console.log(cities);
				Array(7) [ "Manchester", "Liverpool", "Cardiff", "London", "Newcastle", "Bristol", "fulham" ]				
				console.log(newLength);//6
				
				let newLengthDos = cities.push("Burnley");//8

				cities.push("Nottingham");//9

				console.log(newLengthDos);//8
		

			8. unshift(elemento): 

				agregar al principio


			9. pop():

				no toma argum
				eliminar ultimmo elemento
		

			10. shift():
			
				eliminar el primer elemento


			11. slice(indiceComienzo, numElemEliminar):

			indexInicioCorte, indexFinCorte

				eliminar uno o más elementos

				Usando indexOf("elemento")//devuelve su indice y condicional if
				
				1.indice comienzo de corte (indice elemento)

				2. cantidad elementos a eliminar (condicional de acá en adelante)
	
				const cities = ["Manchester", "Liverpool", "Edinburgh", "Carlisle"];
				const index = cities.indexOf("Liverpool");
				if (index !== -1) {
				  cities.splice(index, 1);
				}
				console.log(cities); // [ "Manchester", "Edinburgh", "Carlisle" ]
				
				//empieza a cortar en 1 y frena en 1 (no incluye)

				const cities = ["Manchester", "Liverpool", "Edinburgh", "Carlisle"];
				const index = cities.indexOf("Liverpool");
				if (index !== -1) {
				  cities.splice(index, 2);
				}
				console.log(cities); // [ "Manchester", "Carlisle" ]
				
				//empieza a cortar en 1 y frena en 2 (no incluye)


			12 for... of: 

				acceder a todos los elementos. 

				const birds = ["Parrot", "Falcon", "Owl"];

				for (const bird of birds) {
				  console.log(bird);
				}


			13. map(): 

				modificar elementos
				
				function double(number) {
				  return number * 2;
				}
				const numbers = [5, 2, 7, 6];
				const doubled = numbers.map(double);
				console.log(doubled); // [ 10, 4, 14, 12 ]


			14. filter(): 
				
				crear coincidencia

				crear una nueva matriz que contenga solo los elementos de la matriz original que coincidan con alguna prueba.

				```
				function isLong(city) {
				  return city.length > 8;
				}
				const cities = ["London", "Liverpool", "Totnes", "Edinburgh"];
				const longer = cities.filter(isLong);
				console.log(longer); // [ "Liverpool", "Edinburgh" ]

				```

				definimos un función llamada isLong que toma un parametro city cuando se la llama, retornará los valores de parametros que sean mayores a 8. 

				Al igual que map(), le damos una función al método filter() y filter() llama a esta función para cada elemento de la matriz, pasando el elemento. 
				
				Si la función devuelve verdadero, entonces el elemento se agrega a una nueva matriz. 

				Finalmente devuelve la nueva matriz.


			15. split():

				datos sin procesar contenidos en una cadena grande

				1. único parámetro: 

					el carácter en el que desea separar la cadena.

					devuelve: 

						las subcadenas entre el separador como elementos de una matriz. 

					usa el caracter para crear una matriz
				
				const data = "Manchester,London,Liverpool,Birmingham,Leeds,Carlisle";

				const cities = data.split(",");
				cities;

				1 .divide a data en las comas

				2 recuperar longitud:
					
					con length: ->


			16. longitud y recuperar elementos: 

				operacion en length:

				cities.length;
				cities[0]; // the first item in the array
				cities[1]; // the second item in the array
				cities[cities.length - 1]; // the last item in the array
					
					3. ir en sentido contrario: join() ->

			17. join(): 
				
				Reconstruir cadena a partir de array

				usa el caracter para deshacer la matriz

				podemos especificar diferentes separadores/caract

				const commaSeparated = cities.join(",");
				commaSeparated;

				"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle"
		

			18. toString(): 

				parecido a join pero más limitante

				Con join() puedes especificar diferentes separadores, mientras que toString() siempre usa una coma. 

				reconstruir cadena a partir de array
					
				const dogNames = ["Rocket", "Flash", "Bella", "Slugger"];
				dogNames.toString(); // Rocket,Flash,Bella,Slugger


			reto 1: precios 	

			    Underpants — $6.99
			    Socks — $5.99
			    T-shirt — $14.99
			    Trousers — $31.99
			    Shoes — $23.99

				Total: $83.95


				const list = document.querySelector('.output ul');
				const totalBox = document.querySelector('.output p');
				let total = 0;
				list.innerHTML = '';
				totalBox.textContent = '';

				const products = [
				  'Underpants:6.99',
				  'Socks:5.99',
				  'T-shirt:14.99',
				  'Trousers:31.99',
				  'Shoes:23.99',
				];

				for (const product of products) {
				  const subArray = product.split(':');
				  const name = subArray[0];
				  const price = Number(subArray[1]);
				  total += price;
				  const itemText = `${name} — $${price}`;

				  const listItem = document.createElement('li');
				  listItem.textContent = itemText;
				  list.appendChild(listItem);
				}

				totalBox.textContent = `Total: $${total.toFixed(2)}`;


			reto 2: registro de los elementos 

				push, pop
				
				cuando se ingresan términos en el cuadro de búsqueda, los 5 términos de búsqueda anteriores principales se muestran en la lista. 

				Cuando el número de términos supera 5, el último término comienza a eliminarse cada vez que se agrega un nuevo término en la parte superior, por lo que siempre se muestran los 5 términos anteriores.
			
			const list = document.querySelector('.output ul');
			const searchInput = document.querySelector('.output input');
			const searchBtn = document.querySelector('.output button');

			list.innerHTML = '';

			const myHistory = [];
			const MAX_HISTORY = 5;

			searchBtn.onclick = () => {
			  // we will only allow a term to be entered if the search input isn't empty
			  if (searchInput.value !== '') {
			    myHistory.unshift(searchInput.value);

			    // empty the list so that we don't display duplicate entries
			    // the display is regenerated every time a search term is entered.
			    list.innerHTML = '';

			    // loop through the array, and display all the search terms in the list
			    for (const itemText of myHistory) {
			      const listItem = document.createElement('li');
			      listItem.textContent = itemText;
			      list.appendChild(listItem);
			    }

			    // If the array length is 5 or more, remove the oldest search term
			    if (myHistory.length >= MAX_HISTORY) {
			      myHistory.pop();
			    }

			    // empty the search input and focus it, ready for the next term to be entered
			    searchInput.value = '';
			    searchInput.focus();
			  }
			}



			tareas: 
			
			1. 

				let myString = "Ryu+Ken+Chun-Li+Cammy+Guile+Sakura+Sagat+Juri";

				let myArray = myString.split("+");

				let arrayLength = myArray.length;

				let lastItem = myArray[arrayLength - 1];

			2. 

				let myArray = ["cats", "dogs", "chickens"];

				myArray[0] = "horses";
				myArray[1] = "pigs";

				myArray.unshift("crocodiles");
			
			3. 
				Elimina el último elemento de la matriz.

				Agregue dos nombres nuevos al final de la matriz.

				Repase cada elemento de la matriz y agregue su número de índice después del nombre entre paréntesis, por ejemplo, Ryu (0)


				sacando el último elemento de la matriz usando myArray.pop().

				dos nombres nuevos al final de la matriz usando myArray.push()
				
				usar .forEach() o alguno para repasar cada elemento de la matriz y agregar su número de índice. después del nombre entre paréntesis.

				Tenga en cuenta que cuando utiliza forEach está realizando operaciones en una copia de los elementos de la matriz, no en los elementos de la matriz en sí, por lo que no puede cambiarlos directamente; debe crear el nuevo elemento de la matriz y copiarlo nuevamente.

				Finalmente, debe unir los elementos de la matriz en una cadena usando myArray.join(' - ') y almacenar el resultado en myString.

				let myArray = [
				  "Ryu",
				  "Ken",
				  "Chun-Li",
				  "Cammy",
				  "Guile",
				  "Sakura",
				  "Sagat",
				  "Juri",
				];

				myArray.pop();

				myArray.push("Zangief");
				myArray.push("Ibuki");

				myArray.forEach(function (element, index) {
				  let newElement = `${element} (${index})`;
				  myArray[index] = newElement;
				});

				let myString = myArray.join(" - ");
	

			4. 
				Busque el índice del elemento "Águilas" y utilícelo para eliminar el elemento "Águilas".

				Crea una nueva matriz a partir de ésta, llamada eBirds, que contenga sólo aves de la matriz original cuyos nombres comiencen con la letra "E". 

				Tenga en cuenta que comienza con () es una excelente manera de verificar si una cadena comienza con un carácter determinado.

		
				Deberías empezar por encontrar el índice de "Eagles", usando Birds.indexOf().

				A continuación, utilice el índice con bird.splice() para eliminar el elemento "Águilas".

				Finalmente, puedes usar bird.filter() para obtener una matriz que contenga solo pájaros que comiencen con "E".

				La función pasada a filter() puede usar bird.startsWith() para probar si el pájaro comienza con "E".

				const eaglesIndex = birds.indexOf("Eagles");
				birds.splice(eaglesIndex, 1);

				function startsWithE(bird) {
				  return bird.startsWith("E");
				}
				const eBirds = birds.filter(startsWithE);


		*/

	</script>

</html>